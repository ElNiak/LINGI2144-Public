MCQ 5: Buffer Overflow
**********************

Question 1. Buffer Overflow
---------------------------

..
    From: http://wwwusers.di.uniroma1.it/~parisi/Risorse/QUIZonBO.pdf and https://www.sanfoundry.com/cyber-security-questions-answers-buffer-overflow-1/

.. question:: bo1
   :nb_prop: 4
   :nb_pos: 1

   |  What typically happens when a buffer is overflowed?

   .. negative::

      -  The memory space that comes after the buffer holds the extra data as well as keeping the data that it contained before

   .. negative::

      - The memory chip in the computer gets too big and explodes

   .. negative::

      - Electrons fall out of the memory chip and start a fire

   .. positive::

      - Whatever is in the memory space that comes after the buffer is overwritten

.. question:: bo2
   :nb_prop: 6
   :nb_pos: 1

   |  Where can an attacker who is trying to “smash the stack” put their attack code if the buffer to be overflowed is on the stack?

   .. negative::

      - On the stack before the return pointer

   .. negative::

      - On the stack after the return pointer

   .. negative::

      - In the stack frame of another function

   .. negative::

      - On the heap

   .. negative::

      - In a global variable

   .. positive::

      - All solution


.. question:: bo3
   :nb_prop: 5
   :nb_pos: 3

   |  Which of these library functions are safe as long as you tell it the correct buffer size?

   .. negative::

      - ``gets()``

   .. negative::

      - ``strcpy()```

   .. positive::

      - ``sprintf()``

   .. positive::

      - ``fscanf()``

   .. positive::

      - ``memcpy()``

.. question:: bo1
   :nb_prop: 4
   :nb_pos: 1

   |  How many types of buffer-overflow attack are there?

   .. negative::

      - 4

   .. negative::

      - 5

   .. negative::

      - 3

   .. positive::

      - 2


Question 2. Shell code
----------------------

.. question:: shell
   :nb_prop: 4
   :nb_pos: 1

   | Consider the following vulnerable code:

   .. code-block:: c

        /* vuln.c */
        #include <stdio.h>
        #include <string.h>

        void func(char *name) {
            char buf[100];
            strcpy(buf, name);
            printf("Welcome %s\n", buf);
        }

        int main(int argc, char *argv[]) {
            func(argv[1]);
            return 0;
        }

   | What should you do to remove all potential security:

   .. positive::

      - Compile with ``gcc vuln.c -o vuln -fno-stack-protector -z execstack`` and disable ASLR with ``echo 0 | sudo tee /proc/sys/kernel/randomize_va_space``

   .. negative::

      - Compile with ``gcc vuln.c -o vuln -fno-stack-protector -z no_execstack`` and disable ASLR with ``echo 0 | sudo tee /proc/sys/kernel/randomize_va_space``

   .. negative::

      - Compile with ``gcc vuln.c -o vuln -fno-stack-protector -z execstack`` and disable ASLR with ``echo 2 | sudo tee /proc/sys/kernel/randomize_va_space``

   .. negative::

      - Compile with ``gcc vuln.c -o vuln -fno-stack-protector -z execstack``

   .. negative::

      - Compile with ``gcc vuln.c -o vuln  -z execstack`` and disable ASLR with ``echo 0 | sudo tee /proc/sys/kernel/randomize_va_space``


.. question:: shell2
   :nb_prop: 4
   :nb_pos: 1

   | What look like the disassemble code of the function ``func`` with stack protection: (on 64 bits here to see better)

   .. positive::

      .. code-block:: bash

        (gdb) disass func
        Dump of assembler code for function func:
           0x00000000000006fa <+0>:	push   %rbp
           0x00000000000006fb <+1>:	mov    %rsp,%rbp
           0x00000000000006fe <+4>:	add    $0xffffffffffffff80,%rsp
           0x0000000000000702 <+8>:	mov    %rdi,-0x78(%rbp)
           0x0000000000000706 <+12>:	mov    %fs:0x28,%rax
           0x000000000000070f <+21>:	mov    %rax,-0x8(%rbp)
           0x0000000000000713 <+25>:	xor    %eax,%eax
           0x0000000000000715 <+27>:	mov    -0x78(%rbp),%rdx
           0x0000000000000719 <+31>:	lea    -0x70(%rbp),%rax
           0x000000000000071d <+35>:	mov    %rdx,%rsi
           0x0000000000000720 <+38>:	mov    %rax,%rdi
           0x0000000000000723 <+41>:	callq  0x5b0 <strcpy@plt>
           0x0000000000000728 <+46>:	lea    -0x70(%rbp),%rax
           0x000000000000072c <+50>:	mov    %rax,%rsi
           0x000000000000072f <+53>:	lea    0xce(%rip),%rdi        # 0x804
           0x0000000000000736 <+60>:	mov    $0x0,%eax
           0x000000000000073b <+65>:	callq  0x5d0 <printf@plt>
           0x0000000000000740 <+70>:	nop
           0x0000000000000741 <+71>:	mov    -0x8(%rbp),%rax
           0x0000000000000745 <+75>:	xor    %fs:0x28,%rax
           0x000000000000074e <+84>:	je     0x755 <func+91>
           0x0000000000000750 <+86>:	callq  0x5c0 <__stack_chk_fail@plt>
           0x0000000000000755 <+91>:	leaveq
           0x0000000000000756 <+92>:	retq
        End of assembler dump.


   .. negative::

      .. code-block:: bash

        (gdb) disass func
        Dump of assembler code for function func:
           0x000000000000068a <+0>:	push   %rbp
           0x000000000000068b <+1>:	mov    %rsp,%rbp
           0x000000000000068e <+4>:	add    $0xffffffffffffff80,%rsp
           0x0000000000000692 <+8>:	mov    %rdi,-0x78(%rbp)
           0x0000000000000696 <+12>:	mov    -0x78(%rbp),%rdx
           0x000000000000069a <+16>:	lea    -0x70(%rbp),%rax
           0x000000000000069e <+20>:	mov    %rdx,%rsi
           0x00000000000006a1 <+23>:	mov    %rax,%rdi
           0x00000000000006a4 <+26>:	callq  0x550 <strcpy@plt>
           0x00000000000006a9 <+31>:	lea    -0x70(%rbp),%rax
           0x00000000000006ad <+35>:	mov    %rax,%rsi
           0x00000000000006b0 <+38>:	lea    0xbd(%rip),%rdi        # 0x774
           0x00000000000006b7 <+45>:	mov    $0x0,%eax
           0x00000000000006bc <+50>:	callq  0x560 <printf@plt>
           0x00000000000006c1 <+55>:	nop
           0x00000000000006c2 <+56>:	leaveq
           0x00000000000006c3 <+57>:	retq
        End of assembler dump.

.. question:: shell3
   :nb_prop: 4
   :nb_pos: 1

   | Consider now the following disassembly on 32 bits system without any stack-protection

   .. code-block:: c

        (gdb) disas func
        Dump of assembler code for function func:
           0x004011a9 <+0>:     push   %ebp
           0x004011aa <+1>:     mov    %esp,%ebp
           0x004011ac <+3>:     push   %ebx
           0x004011ad <+4>:     sub    $0x74,%esp
           0x004011b0 <+7>:     call   0x4010b0 <__x86.get_pc_thunk.bx>
           0x004011b5 <+12>:    add    $0x2e4b,%ebx
           0x004011bb <+18>:    sub    $0x8,%esp
           0x004011be <+21>:    pushl  0x8(%ebp)
           0x004011c1 <+24>:    lea    -0x6c(%ebp),%eax
           0x004011c4 <+27>:    push   %eax
           0x004011c5 <+28>:    call   0x401040 <strcpy@plt>
           0x004011ca <+33>:    add    $0x10,%esp
           0x004011cd <+36>:    sub    $0x8,%esp
           0x004011d0 <+39>:    lea    -0x6c(%ebp),%eax
           0x004011d3 <+42>:    push   %eax
           0x004011d4 <+43>:    lea    -0x1ff8(%ebx),%eax
           0x004011da <+49>:    push   %eax
           0x004011db <+50>:    call   0x401030 <printf@plt>
           0x004011e0 <+55>:    add    $0x10,%esp
           0x004011e3 <+58>:    nop
           0x004011e4 <+59>:    mov    -0x4(%ebp),%ebx
           0x004011e7 <+62>:    leave
           0x004011e8 <+63>:    ret
        End of assembler dump.

        (gdb) disass main
        Dump of assembler code for function main:
           0x004011e9 <+0>:     lea    0x4(%esp),%ecx
           0x004011ed <+4>:     and    $0xfffffff0,%esp
           0x004011f0 <+7>:     pushl  -0x4(%ecx)
           0x004011f3 <+10>:    push   %ebp
           0x004011f4 <+11>:    mov    %esp,%ebp
           0x004011f6 <+13>:    push   %ecx
           0x004011f7 <+14>:    sub    $0x4,%esp
           0x004011fa <+17>:    call   0x401227 <__x86.get_pc_thunk.ax>
           0x004011ff <+22>:    add    $0x2e01,%eax
           0x00401204 <+27>:    mov    %ecx,%eax
           0x00401206 <+29>:    mov    0x4(%eax),%eax
           0x00401209 <+32>:    add    $0x4,%eax
           0x0040120c <+35>:    mov    (%eax),%eax
           0x0040120e <+37>:    sub    $0xc,%esp
           0x00401211 <+40>:    push   %eax
           0x00401212 <+41>:    call   0x4011a9 <func>
           0x00401217 <+46>:    add    $0x10,%esp
           0x0040121a <+49>:    mov    $0x0,%eax
           0x0040121f <+54>:    mov    -0x4(%ebp),%ecx
           0x00401222 <+57>:    leave
           0x00401223 <+58>:    lea    -0x4(%ecx),%esp
           0x00401226 <+61>:    ret
        End of assembler dump.

        (gdb) x/100xw buf
        0xbffff28c:     0x00000001      0x00000000      0x00000001      0xb7fff950
        0xbffff29c:     0x00000001      0x00000000      0x00c30000      0x00000001
        0xbffff2ac:     0xb7ffe840      0xbffff300      0x00000000      0xb7fff000
        0xbffff2bc:     0x00000000      0x00000000      0xbffff3c4      0xb7fb8000
        0xbffff2cc:     0xb7fb69e0      0x00000000      0xb7fb8000      0xb7ffe840
        0xbffff2dc:     0xb7fbbd08      0xb7fe62d0      0xb7fb8000      0x00000000
        0xbffff2ec:     0xb7e169eb      0xb7fb83fc      0x00000000      0xbffff318
        0xbffff2fc:     0x00401217      0xbffff56f      0xbffff3c4      0xbffff3d0
        0xbffff30c:     0x004011ff      0xb7fe62d0      0xbffff330      0x00000000


   | What is the size/space allocated by for the buffer:

   .. positive::

      - 116 bytes

   .. negative::

      - 100 bytes

   .. negative::

      - 174 bytes

   .. negative::

      - 16 bytes


.. question:: shell4
   :nb_prop: 4
   :nb_pos: 1

   | Tell which statement is true:

   .. positive::

      - The address of the saved EIP is ``0x00401217``
      - The address of the saved EBP is ``0xbffff318``
      - The address of the start buffer is ``0xbffff28c``

   .. negative::

      - The address of the saved EIP is ``0x00401212``
      - The address of the saved EBP is ``0x00401217``
      - The address of the start buffer is ``0xbffff28c``

   .. negative::

      - The address of the saved EIP is ``0x00401211``
      - The address of the saved EBP is ``0x00401212``
      - The address of the start buffer is ``0xbffff28c``

   .. negative::

      - The address of the saved EIP is ``0x00401217``
      - The address of the saved EBP is ``0xbffff318``
      - The address of the start buffer is ``0x00000001``

   .. negative::

      - The address of the saved EIP is ``0x004011a9``
      - The address of the saved EBP is ``0x004011e8``
      - The address of the start buffer is ``0xbffff28c``

.. question:: shell5
   :nb_prop: 6
   :nb_pos: 1

   | Now you have all the information needed to inject your shellcode of 55 bytes and erase the saved EIP with the address of the start buffer, for that we will need ...

   .. positive::

      - 69 NOPs

   .. negative::

      - 53 NOPs

   .. negative::

      - 57 NOPs

   .. negative::

      - 64 NOPs

   .. negative::

      - 45 NOPs

   .. negative::

      - 61 NOPs