Buffer Overflow
***************

In the first part of the class, we will assume a very permissive situation: we can do whathever we want with the stack!

The Blaster/Lovesan worm
------------------------

Description:

-  Appeared in Summer 2013

- Causes computers to reboot, freeze, perturbate cut and past, ..

- Syn flood attack, impact windows update

- 2 billions USD

Origins:

- Exploit a vulnerability of the RCP in Windows XP

- Idea: overruns the buffer's boundary and overwrites adjacent memory locations

- This is a Buffer Overflow (BO)

Exploit: Erase value of other local variables
----------------------------------------------

.. literalinclude:: prog.c
   :language: c

-  ``./prog coucou`` :math:`\rightarrow` bad password!

-  ``./prog good`` :math:`\rightarrow` access granted

-  ``./prog badbadbadbadbadbadbad`` :math:`\rightarrow` bad
   password!\ **access granted**

-  ``./prog badbadbadbadbadbadbadbadbadbadbadbadbadbad``
   :math:`\rightarrow` **Segmentation fault**

+----------------------------------+------------------------------------------+
| Effect on the stack              | Exploits, strongly depend on variable’s  |
|                                  | position:                                |
+==================================+==========================================+
| 1. Exceed buff capacities        | 1. Erase another variable                |
+----------------------------------+------------------------------------------+
| 2. Erase/change informations :   | 2. Get access to function informations   |
|    Local variables or function’s |                                          |
|    prolog                        |                                          |
+----------------------------------+------------------------------------------+

.. image:: /buffer_overflow/image/16.PNG
   :scale: 70%
   :align: center

With GDB
~~~~~~~~
.. literalinclude:: gdb1.c
   :language: c

-  ``b  *0x5655560d``

   -  Knowing the value of EBP and next instruction before function
      ``check_authentification`` is called

      -  ``i r ebp: ebp 0xffffd118 0xffffd118``

      -  Before calling ``check_authentification``: Next instruction is
         ``0x56555612`` and EBP points to ``0xffffd118``

   -  We know that they’re saved on the stack before local variables and
      we can identify their value

   -  Hence, we can guess position of ``password_buff``

-  ``b  *0x565555a0``

   -  Then try to find the above values in the stack by printing from
      ``password_buff`` er in the stack

   -  Gives an idea of how much you need to erase, i.e , of the size of
      password

      -  ``x/24xw password_buffer``

      .. literalinclude:: gdb2.c
          :language: c

      Warning, the position of those addresses varies with the size of password.

      -  ``print &auth_flag`` :math:`\rightarrow`
         ``$1 = (int *) 0xffffd0ec``

      -  ``print &password_buffer`` :math:`\rightarrow`
         ``$2 = (char (*)[16]) 0xffffd0dc``

-  **Conclusion**

   #. 17 bytes are enough to start erasing ``auth_flag``

   #. 28 are enough to start erasing ``saved EBP``

   #. 32 are enough to start erasing next instruction ``saved EIP``

   May still crash, also depend on data alignment made by the compiler.


.. warning:: **Values depends on the size of the parameters values
   = addresses and space allocated.**


Could it still be crashed ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. literalinclude:: auth.c
   :language: c

-  Depends on the compiler

-  We should not rely on order of variable as prevention

Stack protection
~~~~~~~~~~~~~~~~

Writable stack
^^^^^^^^^^^^^^

For some exploits, it is important to be able to **execute
instructions** written on the stack, no canary.

-  ``gcc -m32 -fstack-protector password.c o password``

-  ``gcc -m32 -fno-stack-protector password.c o password``

On a compiled software: much harder to know if protection is applied.
What would you do in case this protection is activated ?

Vulnerable functions
^^^^^^^^^^^^^^^^^^^^

-  ``strcat(), strcpy()``

-  ``sprintf(), vsprintf()``

-  ``gets()``

-  ``scanf()`` and ``family``

-  ``realpath(), index(), getopt(), getpass(), strecpy(), streadd(), strtns()``

.. include:: exploit2.rst
.. include:: exploit3.rst
