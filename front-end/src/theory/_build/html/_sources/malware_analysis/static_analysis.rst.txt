Static Analysis
----------------

Example
~~~~~~~

.. literalinclude:: staticmal.c
    :language: c

| The malware’s behavior is to print the string “I am evil!!!”.
| We will look for programs that produce this string but how do we
  determine if a program has this malicious behavior ? How to know that
  this string is indeed the malicious behavior to hunt?

Static Analysis: Signatures are sequences of strings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-  **Principle**: look for relevant strings in the binary ( that’s your
   signature

-  How do the signatures look like?

   -  composed of characteristic strings extracted from the malware

   -  other property that can be quickly verified without executing,
      e.g., hash and size

-  How do we extract the signature from a binary?

   -  major challenge, but when you’ve it you’re happy!

   -  avoid false positive, false negative

-  Before talking about the extraction, let us see what we can do when
   we have it!

Static Analysis: processing new files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-  **Challenge**: How to detect a potential new malware M1?

-  **Solution:**

   -  Compile all signatures of known malwares in a regular expression
      (**classification**)

   -  and scan the binary of M1 to see if any part matches
      (**detection**)

-  This is a **Pattern matching** approach (remember your translator
   class!)

-  It is mostly performed via **automata**:

   -  Turn regular expression into automaton

   -  Walk M1 file in the automaton and check if you reach an accepting
      state

-  A well known tool: ``YARA``

Malware detection static via ``YARA``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Yara IS:

-  **Elegant way to specify any type of regular expression**

-  Fast and efficient at detection

-  Look for syntactic properties of file

-  Does not execute the sample during analysis (i.e. static)

-  Plugins to python and other languages

-  Protections against **REGEX attacks**

   -  Remember : Regular expression are turned into automaton

   -  If automaton is deterministic then one path

   -  If automaton is non deterministic which arises for complex regular
      expressions), then exponential number of paths

   -  Example:

      -  regular expression: ``[a-z]+@[a-z]+([a-z \.]+.]+\.)+[a-z]+``
         for mail

Yara IS NOT:

-  a virus scanner (but act very similar to existing anti virus)

-  a correlation engine

-  a bayesian classifier

-  Or more generally: an artificial intelligence

Rules can be very complex, but can be written in a very effective manner [3]_


.. literalinclude:: yara.c
    :language: c

**Main difficulty**: how to write good (effective) YARA rules? I.e. How
to identify and extract malicious knowledge from a known database?

-  **Things to avoid:**

   #. Rules that generate many false positives and

   #. Rules that match only the specific sample and are not much better
      than a hashvalue.

-  **Solutions:**

   #. Comparison with cleanware database (**reduce false positive**
      :math:`=` Happens when the rule claims it is a malware, but it is
      not)

      #. Take a huge database of cleanware

      #. Take a malware

      #. Create a rule with strings that are specific to malware, and
         not present (or almost not present) in the cleanware

      May generate plenty of strings

      #. Take the x best ones

      #. Best has to be defined.

      | ``yarGen``: Keep strings that are likely to not be in goodware.
      | Avoid false positive: Do not claim it is a malware if it not
      | **Danger**:

      -  Rules may become too specific

      -  Strings that were present in the sample used as malware may not
         be part of the malware

      -  And hence not present in another iteration of the same malware

      -  Consequence: no detection!

      Example
      https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/
      (**ToREAD**)

   #. | Good practice (**avoid false negative**, less specific)
      | Best practice by Florian Roth:

      #. | **Very specific strings** ($s) s)\ :math:`=` hard indicators
           for a malicious sample
         | Ex: typos: „ Micorsoft Corportation “ instead of „Microsoft
           Corporation“ and Monnitor “ instead of „

      #. **Rare strings** :math:`=` likely that they do not appear in
         goodware samples, but possible

      #. **Strings that look common** :math:`=` (Optional) e.g. yarGen
         output strings that do not seem to be specific but didn’t
         appear in the goodware string database

      #. **Question?** How to rank the importance of the strings in the
         rules?

Automatized in a tool: yarGen
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

-  Author: Florian Roth

-  Repository: https://github.com/Neo23x0/yarGen

-  Purpose: automatic creation of YARA rules

   « The main principle is the creation of YARA rules from strings found
   in malware files while removing all strings that also appear in
   goodware files. »

Process
^^^^^^^

.. image:: image/37.PNG
   :scale: 50%
   :align: center

Static Analysis: Syntactic Pattern Matching: Obfuscation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

https://hal.inria.fr/hal-01964222/file/main.pdf (**ToRead**)

.. literalinclude:: staticmal2.c
    :language: c

| **Observation**: Signature “I am evil!!!” is not detected anymore!
| Can obfuscate with:

-  Easy to obfuscate, just split the strings in the code... with
   ``strncat`` and ``strcpy``

-  More advanced technique: encoding (byte code, xor + key)

.. literalinclude:: xor.c
    :language: c


Problem: Packing Detection
~~~~~~~~~~~~~~~~~~~~~~~~~~

-  Code gets compressed/encrypted and only decrypted at runtime
   (possibly one piece at the time)

.. image:: image/38.PNG
   :scale: 50%
   :align: center

-  Very effective against any static technique: as hard as breaking
   encryption

-  Difficulties:

   #. Hard to know if the program is packed

   #. And by who necessary to unpack

-  Solution: To unpack we need to know which technique was used.


#. **YARA**

.. literalinclude:: yara2.C
    :language: c

2. **Machine learning**: we use **signature based Machine Learning
   classification**

   #. **training**:

      -  Extract relevant features from binaries

      -  Link features to pack/unpack informations + name of packer (if
         possible, Based on your knowledge)

      -  Create a ground truth for training ML classifiers (test several
         algorithms, Generalization step.)

   #. **testing**:

      -  Use the result to decide if a file is packed

      -  | Efficiency is very important, two questions: Packed or
           unpacked? Packed by who?


What is a feature ?

+------------------------------------+---------------------------------------------------------------+
| Static features:                   | Dynamic features:                                             |
+====================================+===============================================================+
| -  Number of non standard sections | -  Repeated instruction execution                             |
|                                    |                                                               |
| -  Import table size               | -  Execution of data section                                  |
|                                    |                                                               |
| -  File header entropy             | -  Execution of previously written memory                     |
|                                    |                                                               |
| -  ...                             | -  ...                                                        |
|                                    |                                                               |
| -  Extraction time:  10 ms/file    | -  Extraction time:  1 s/file                                 |
|                                    |                                                               |
|                                    | -  In practice: Dynamic features are too expensive to extract |
+------------------------------------+---------------------------------------------------------------+

.. image:: image/39.PNG
   :scale: 35%
   :align: center

Packing Detection: Ground Truth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ML techniques are as good as the data used to train them. Binaries are
chosen for ground truth by combining:

+-----------------------------+----------------------------------------+----------------------------------------+
| **Hash based**              | **Static signatures**                  | **Proprietary tools**                  |
| Proprietary analyzer        |                                        |                                        |
+=============================+========================================+========================================+
| -  No access to tool source | -  Multiple sources: YARA, PeID…       | Often done with manual experience and  |
|                             |                                        | hash based                             |
| -  High quality detection   | -  Detects byte patterns of packers in |                                        |
|                             |    binaries                            |                                        |
| -  Only on known binaries   |                                        |                                        |
|                             | -  Detects packing on unknown binaries |                                        |
+-----------------------------+----------------------------------------+----------------------------------------+

| Build ground truth based on **consensus** of these techniques.
| ML techniques are as good as the data used to train them

.. literalinclude:: yara3.C
    :language: c

.. image:: image/40.PNG
   :scale: 50%
   :align: center

Packing Detection: ML Classifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We test ML classifiers of various complexity:

#. **Naive Bayesian Classifier** : performs Bayesian hypothesis testing
   assuming independence of features

#. **Decision Tree** : determines order of feature testing based on
   greedy entropy minimization

#. **Random Forest** : uses majority voting on multiple Decision Trees
   to avoid local maxima

#. **Nearest Neighbors** : clusters similar elements according to a
   distance metric

#. ...


Algorithms are evaluated on:

#. Effectiveness (by F-score)

#. Training time

#. Classification time


Packing Detection: Preliminary Results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Preliminary results on ML classifiers tested:

.. image:: image/41.PNG
   :scale: 50%
   :align: center

-  Database of 160k unpacked and 40k packed PE files

-  Used 80% of database for training, 20% for testing

-  All classifiers are very effective (even simple ones)

-  Decision tree is very cost effective

-  Decide classifier to use according to available time

Preliminary results on most relevant features: [4]_

.. image:: image/42.PNG
   :scale: 50%
   :align: center

| As expected, entropy is important to detect packing.
| Packing classification relies on finer features, like:

-  Specific bytes after entry point

-  Presence of non standard sections

-  Use of rarely used system calls

+-------------------------------------------------------------------------+--------------------------------------------------------+
| :math:`\Rightarrow` **Situation** :math:`=`                             | :math:`\Rightarrow` **Next** :math:`=`                 |
+=========================================================================+========================================================+
| -  Static analysis is a fast and efficient way to detect known malwares | -  Let us try to detect signatures *at execution time* |
|                                                                         |                                                        |
| -  With known signatures                                                | -  This is the **dynamic analysis** approach.          |
|                                                                         |                                                        |
| -  The approach is not robust to obfuscation                            |                                                        |
+-------------------------------------------------------------------------+--------------------------------------------------------+


.. [3]
   https://yara.readthedocs.io/en/stable/

.. [4]
   \* computed as mean decrease impurity on tree based algorithms

