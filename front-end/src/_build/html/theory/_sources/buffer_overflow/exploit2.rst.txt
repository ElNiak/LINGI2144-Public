Exploit: DoS
------------

-  **Objective**: break the availability attribute

-  **Idea** : put the system into an infinite loop, consumes energy ,
   but do not make progress anymore

-  How would you create an infinite loop ?

   -  When instruction ``ret`` is performed, the stack still contains
      the parameters from the calling function. Consequently, if one
      replaces the next instruction address saved on the stack by the
      one of the call of the function. Then one can enter in an infinite
      loop where the function call itself forever , or until ressources
      are exhausted

   .. literalinclude:: dos.c
       :language: c

   If ``EIP`` is detected 44 bytes after the beginning of ``newbuffer`` in
   foo then this modified main will put the system in an infinite loop.
   At this stage, the exploit is artificial but foo could be running on
   a remote server. The main difficulty would be to obtain its address
   which is no so difficult if one gets access to.

Stack protection
~~~~~~~~~~~~~~~~

Randomized ESP
^^^^^^^^^^^^^^

| One very powerful protection is to randomize ESP based on entropy
  which will make harder to find where the (top of the) stack is. It’s
  at kernel level :

.. centered:: ``echo x | sudo tee /proc/sys/randomize_va_space``

| with if ``x=0``, randomization is disabled , if ``x=2`` then it is enabled.

| **What could you still use in case this protection is activated
  ?**\  [1]_ Attacker returns to a function’s PLT (whose address is NOT
  randomized – its address is known prior to execution itself). Since
  ‘``function@PLT``’ is not randomized, attacker no more needs to predict
  buffer base address instead he can simply return to ‘function@PLT’
  inorder to invoke ‘function’. See later.

.. [1]
   https://sploitfun.wordpress.com/2015/05/08/bypassing-aslr-part-i/