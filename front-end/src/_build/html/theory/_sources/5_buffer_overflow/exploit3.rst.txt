Exploit: Shellcode
------------------

| The BO vulnerability can also be used to launch **malicious code**,
  called **the payload of the attack** in exploitation of a software
  vulnerability, often takes the name of **shellcode**. It can be used,
  e.g., to get access and take control of another machine.

.. note:: **Shell code are not program , but self sufficient piece of
   code (in the code segment and nothing else). Indeed, they shall be
   runned without context. Programming shellcode is an art, here we will
   mainly focus on using them.**

| There are various type of shell codes:

#. | **Local shellcode** is used by an attacker who has limited access
     to a machine. Main objective: spawn a shell with root privileges
     (**Stack must be executable and writable**)
   | **Idea:**

   -  Erase ``saved EIP`` so that the attacker controls next instruction
      to be executed

   -  Push a new value for ``saved EIP`` which is inside the stack and
      where the attacker has placed a malicious payload

   -  Use nops (``\x090``)to avoid compiler missmatches it is hard to
      know the precise value of ESP

.. image:: /buffer_overflow/image/17.PNG
   :scale: 50%
   :align: center

#. **Remote shellcode** is used to target a vulnerable process running
   on another machine on a local network, intranet or a remote network
   in order to gain access

#. **Download and execute shellcode** is a type of remote shellcode that
   downloads and executes some form of malware on the target system
   (sequence of instructions, PM detection!)

#. **Staged shellcode** executes the remote shellcode by stages. First,
   a small piece of shellcode (stage 1) is executed. This code then
   downloads a larger piece of shellcode (stage 2) into the process’s
   memory and executes it

Smatch the stack
~~~~~~~~~~~~~~~~

Two Questions:

#. How does attacker know where buffer starts on the stack ?

#. How does attacker know where to put Return address in the input to
   overwrite ``<ret>`` ?

Let’s see an example

.. literalinclude:: stacksmash.c
   :language: c

**To inject a shell code, we need to know (This is done by "guessing" and
depends on other local variables/parameters):**

#. the size of shellcode (does it fit in the buffer)

#. The address where ``EIP`` is saved (to be erased to redirect to the
   shell code)

#. The address of the buffer (to know where the shellcode really is)

.. literalinclude:: gdb3.c
   :language: c

Break before and after ``strcpy`` to visualize the evolution of the
buffer content : ``x/30xw buffer``

.. literalinclude:: gdb4.c
   :language: c

.. literalinclude:: gdb5.c
   :language: c

| Here is a shellcode (depend on architecture) of 45 bytes that open a
  shell :
| ``"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56"``
| ``"\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"``

| A payload of 31 NOPS :math:`+` Shell code :math:`+` new return address
  should be enough. Buffer starts at address ``0xffffd080``, and so
  should do the 31 NOPS. To make it safer, take one between
  ``0xffffd080`` and ``0xffffd080 + 31``

.. literalinclude:: bo.sh
   :language: bash

Stack protection
~~~~~~~~~~~~~~~~

Executable stack
^^^^^^^^^^^^^^^^

It may be important to execute instructions written on the stack.

-  ``gcc -m32 -z execstack password.c o password``

On a compiled software:

.. literalinclude:: readelf.sh
   :language: bash

Some possible issues
~~~~~~~~~~~~~~~~~~~~

#. **Buffer too small**

   -  Erase ``saved EIP`` so that the attacker controls next instruction
      to be executed

   -  Push the shellcode after ``saved EIP``

   -  Replace ``saved EIP`` by the next address.

.. image:: /buffer_overflow/image/18.PNG
   :scale: 70%
   :align: center

2. **In practice**: the vulnerable part will be called from another program,
   this may change the position of the return address by few words which
   justifies the NOP sleed. May push the situation from adequate size
   buffer to too small buffer.

   -  ``. "\x90\xd0\xff\xff"``: SEGFAULT

   -  ``. "\xd0\xd0\xff\xff"``: Ok nice shell

3. Here the shellcode has been passed as ``argv[]`` in main. In
   practice, it is better to write another program that triggers the
   shellcode. Most compilers add extra checks to bane shell code as
   main’s argument

