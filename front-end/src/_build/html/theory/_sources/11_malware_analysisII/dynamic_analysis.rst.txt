Dynamic Analysis
-----------------

**Principle**: execute the binary, analyze the memory looking for
malicious behavior (in our case, “I am evil!”)

-  Works for ``strcpy("i am ");strncat(a, " evil ");printf(a)``

-  Does not work for ``printf("i am "); printf(" evil ")``

.. image:: image/43.PNG
   :scale: 50%
   :align: center

How do we look for the signature in a binary?

-  The binary is executed in a virtualized environment.

-  The memory **is dumped** at various times during execution, and

-  Search for the **signature** in the dump.

But what can be a signature now?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

| In static analysis, signatures are defined as (sets of) string(s)
  :math:`+` special flags. Observing malwares at runtime allows for new
  perspectives.
| A signature can be:

-  Any type of observable behavior

-  Example: A sequence of logs (hock the logs)

-  Very important, e.g., in case of packing strings are obfuscated

**Main difficulty**: make sure that the malware does not know it is
observed!

Dynamic Analysis: virtualized environment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Complexity: **high**

-  Requires setting up and maintaining the emulation of a realistic
   environment

-  Each file analysis requires time to execute the sample plus time to
   reflash and restart virtualized environment

Tools/software
^^^^^^^^^^^^^^

| There are various virtualized environment:

-  Sandboxes: Cuckoo, VirusTotal , sandboxie

-  Virtual machines: VirtualBox, …

-  Native hypervisors

| There are various tools to dump memory: ``LiMe``, ``fmem``,
  ``HBGary``, ...
| There are many tools to examine a dump: ``Volatility`` (works with
  python, embeds dynamic version of YARA)

Computer system : abstract architecture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sandbox
^^^^^^^

-  Everything installed stays inside

-  Cannot be viewed from external world

-  Not saved when application exits

-  Hock calls, observe, …

-  Time out after some time

.. image:: image/44.PNG
   :scale: 50%
   :align: center

**Limits**

-  Does not analyze malware if it requires command line arguments or
   packets from C&C server

-  Sleep and similar operations can timeout analysis

-  Multi file malware (e.g. with DLLs) not analyzed

-  May have incorrect environment e.g. OS type

-  Analysis result may be hard to understand

Virtual machines
^^^^^^^^^^^^^^^^

.. image:: image/45.PNG
   :scale: 50%
   :align: center

**Limits**

-  Not lightweight

-  Reconstitute a computer within a computer

-  Can still be detected

-  | **Other solutions**: hypervisor (beyond this introduction)

Am I in a VM ?

.. literalinclude:: vm.c
    :language: c

Summary
^^^^^^^

#. Dynamic analysis forces to execute the malware, this goes beyond
   static analysis

#. But may requires more sophisticated deployments

#. Unfortunately: all virtual environments can be detected and evaded

#. When a malware is executed, one can get information with memory dump

What is memory forensics ?
~~~~~~~~~~~~~~~~~~~~~~~~~~

-  Data are stored in either main memory unit or auxiliary memory unit

-  RAM (Random Access Memory) is the main memory unit

-  It retrieves the programs or data from the auxiliary memory unit

-  It temporarily stores the information until the power is turned off.

“Memory forensics is forensic analysis of a computer’s memory dump. Its
primary application is investigation of advanced computer attacks which
are stealthy enough to avoid leaving data on the computer’s hard drive.
Consequently, the memory (RAM) must be analyzed for forensic
information. [From Wikipedia]"

There are at least two main reasons to observe the physical memory:

#. Contains data related to the real time execution of the system

   -  Currently mounter file system

   -  List of active processes, connections, …

#. Encrypted data are generally decrypted before being used

   -  Password is now visible, …

   -  Code is unpacked before being executed

Memory dump and memory profil
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-  **Main difficulty**: organisation of memory depends of architecture
   and kernel symbols

-  This information is called the **memory profil** (can be created from
   distribution)

-  When dumping memory it is of interest to specify the memory profil

-  If it is unknown , we obtain a "**raw**" **memory dump**

-  In this case, tools exists to identify the dump (but they are not
   perfect)"

-  Dumping memory is not hard

-  Retrieving informations from dump requires to know the profil

-  Identifying profil is thus crucial

-  This class does not aim to investiguate the shape of memory

-  However, students need to understand that there is no tool able to
   handle all memory shape and all architecture

Sample of tools to dump memory (Linux)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+------------------------------------------------------------------------+---------------------------------------------------------------------+
| ``LiME``                                                               | ``dd`` command                                                      |
+========================================================================+=====================================================================+
| -  Loadable kernel module                                              | -  ``dd`` can copy files of various sizes (``dd`` if = origine of = |
|                                                                        |    destination)                                                     |
| -  first tool that can perform entire memory dumps from Linux devices  |                                                                     |
|    and from Android.                                                   | -  In Linux, all the devices are managed through files              |
|                                                                        |                                                                     |
| -  Perform memory dumps by loading modules immediately after compiling | -  physical memory data are in ``/dev/mem`` file                    |
|    without any other operations, such as a change in kernel settings   |                                                                     |
|                                                                        | -  However, recent versions restrict access to memory stored in     |
| -  Work with both 32 and 64 bits                                       |    ``/dev/mem``                                                     |
|                                                                        |                                                                     |
| -  Can generate its own memory format for compatibility with analysis  | -  Work with both 32 and 64 bits                                    |
|    tools                                                               |                                                                     |
+------------------------------------------------------------------------+---------------------------------------------------------------------+

Lime: Illustration
^^^^^^^^^^^^^^^^^^

-  | The following command:
   | ``sudo insmod lime 4.18.0 17 generic.ko "path=/home/axel/memory.mem format=lime"``
   | Creates a lime format copy of the RAM and write it into
     ``/home/ memory.mem``

-  Observe that lime ``4.18.0-17-generic.ko`` is the lime module
   directly identified by Lime during installation on your distribution!
   (LiMe version directly link to you kernel distribution version
   because it need to keep the structure of you memory!)

-  It actually depends on the memory ``System.map`` in ``/boot``
   directory!

-  To clean up: ``rrmod lime``

Sample of tools to dump memory (Windows)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+-----------------------------------------------------+-----------------------------------------------+
| ``Dumpit``                                          | ``OllyDBG`` and ``LordPE``                    |
+=====================================================+===============================================+
| -  generate a physical memory dump of Windows       | -  Free                                       |
|    machines.                                        |                                               |
|                                                     | -  Only works properly on 32 bit architecture |
| -  The raw memory dump is generated in the current  |                                               |
|    directory                                        |                                               |
+-----------------------------------------------------+-----------------------------------------------+

Sample of tools to dump memory (disassembler)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

| Most of disassembler have their own memory dump
| :math:`\Rightarrow` ``GDB``

-  ``dump binary memory result.bin 0x200000000 0x20000c350``

:math:`\Rightarrow` ``x64dbg``

-  Scylla Plugin

:math:`\Rightarrow` ``IDA, RADARE``,...

The ``volatility`` framework
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Introduction
^^^^^^^^^^^^

| Volatility is an open source memory forensics framework for incident
  response and malware analysis. Volatility is written in ``python``.

| Volatility can be used to retrieve information from memory dump:

-  List of processes

-  connections

-  Dump process from memory for finer analysis

-  Process organization structure

-  Command link to process

-  Yara (pattern matching inside

-  Malfind (detect known)

-  ...

Supports
^^^^^^^^

Volatility Framework support (taken from their website):

-  memory dumps from all major 32 and 64 bit Windows

-  Linux memory dumps in raw or LiME format and include 35+ plugins for
   analyzing 32 and 64 bit Linux kernels from 2.6.11 3.16 and
   distributions such as Debian, Ubuntu, OpenSuSE , Fedora, CentOS, and
   Mandrake

-  38 versions of Mac OSX memory dumps from 10.5 to 10.9.4 Mavericks,
   both 32 and 64 bit. Android phones with ARM processors are also
   supported

But is is likely that you’ll have to create your own profile (especially
for Linux)

Profile creation (linux)
^^^^^^^^^^^^^^^^^^^^^^^^

| A profil contains: kernel data structures (``.dwarf``) and debug
  symbols (``.map``)

| Remember:

-  it is used to locate critical information inside the memory dump

-  Hence to understand the structure of the memory.

It’s imperative that the profile is created on the same machine to be
analyzed. Indeed, kernel data structure and debug symbols are specific
to distribution and kernel used.

#. Create the kernel data structure

   -  Use ``dwarf`` for debugging information

   -  ``axel@axel-VirtualBox:~/volatility/linux ls``

      ``info kcore Makefile Makefile.enterprise module.c module.dwarf``

#. Get the kernel symbols of the current kernel

   -  tells Volatility how are memory analysis snapshot structured

   -  ``axel@axel VirtualBox :~ ls /boot/System*``

      ``/boot/System.map-4.18.0-16-generic /boot/System.map-4.18.0-17-generic``

#. Archive the profile

   -  in ``/volatility/volatility/plugins/linux``

   -  ``zip nomprofil.zip /boot/System.map-4.18.0-17-generic/volatility /linux.module.dwarf``

Quick usage illustration
^^^^^^^^^^^^^^^^^^^^^^^^

-  | Command line:
   | ``python vol.py (--profil=profiltodefine) -f file (-p processnumber)  command``

-  To know the list of available profiles: ``python vol.py --info``

-  | Example: how to list all process from dump ``memory.mem`` with
     profil ubuntu
   | ``python vol.py --profil=ubuntu -f memory.mem linux_pslist``

-  Can be combined with Yara and other tools

A note on installation
^^^^^^^^^^^^^^^^^^^^^^

``sudo apt get install volatility`` works for linux but is not providing
a nice structure to add profiles (especially overlay directory). Better
to follow installation from original website:

https://github.com/volatilityfoundation/volatility/wiki/Installation#getting-volatility

Fully integrated version for windows: ``volatility_standalone``

Relation with virtual machine
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

| Tool such as Virtualbox allow us to perform memory dump of a virtual
  machine.
| Example:
  ``vboxmanage debugvm "windows10"  dumpvmcore --filename test.elf``

-  Extract dump of Ubuntu 2019 and place it into ``test.elf``.

-  Vboximage are always ELF files (even if windows runs inside the
   machine!)

**Important**: ``test.elf`` contains the entire virtualbox environment,
that is not only the RAM of the system running within windows10 , but
also the RAM for the entire machine. One must thus locate the RAM of the
system running within the machine, that is to identify the first LOAD
section , and take a subimage.

https://www.andreafortuna.org/2017/06/23/how-to-extract-a-ram-dump-from-a-running-virtualbox-machine/

.. warning:: **The entire raw memory occupied by the machine will be
   dumped. As an example, if 10GB of raw memory are allocated to the
   machine, then they’ll be all dumped. Even if they are not entirely
   used by the machine.**

| **Problem**: tools may not be able to analyse such size (extract sub
  image, save, etc

-  Configure your machine properly when you perform an analysis

The limit of static yara analysis
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider that any program which prints "catanddog123" is a malware. The
following yara rule should be able to catch such malware:

.. literalinclude:: yara4.c
    :language: c

However , the following program (test.c) will not be detected

.. literalinclude:: test.c
    :language: c

Nothing happened ; Yara found nothing, this is because « catanddog123 »
is not in stored in the file. However , it appears in memory before it
is printed.

-  Solution: dump the memory and apply yara on it

-  Remember : memory contains almost everything you need

Dynamic Yara analysis in action
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. image:: image/46.PNG
   :scale: 50%
   :align: center

.. image:: image/47.PNG
   :scale: 50%
   :align: center

|

| There are several tutorial availables:

https://eforensicsmag.com/finding-advanced-malware-using-volatility/

It assumes that a dump of the problematic file has been created under
``vinfected.vmem``.

